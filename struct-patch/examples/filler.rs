use struct_patch::Filler;
#[cfg(feature = "status")]
use struct_patch::Status;

#[derive(Default, Filler)]
#[filler(attribute(derive(Debug, Default)))]
struct Item {
    field_complete: bool,
    field_int: usize,
    field_string: String,
    maybe_field_int: Option<usize>,
    maybe_field_string: Option<String>,
    list: Vec<usize>,
}

// Generated by Filler derive macro
//
// #[derive(Debug, Default)] // pass by filler(attribute(...))
// struct ItemFiller {
//     maybe_field_int: Option<usize>,
//     maybe_field_string: Option<String>,
// }

fn main() {
    let mut item = Item::default();

    let mut filler: ItemFiller = Item::new_empty_filler();

    #[cfg(feature = "status")]
    assert!(filler.is_empty()); // provided by Status

    filler.maybe_field_int = Some(7);

    #[cfg(feature = "status")]
    assert!(!filler.is_empty());

    assert_eq!(
        format!("{filler:?}"),
        "ItemFiller { maybe_field_int: Some(7), maybe_field_string: None, list: [] }"
    );

    item.apply(filler);

    assert!(!item.field_complete);
    assert_eq!(item.field_int, 0);
    assert_eq!(item.field_string, "");
    assert_eq!(item.maybe_field_int, Some(7));
    assert_eq!(item.maybe_field_string, None);
    assert_eq!(item.list.len(), 0);

    let mut filler: ItemFiller = Item::new_empty_filler();
    filler.maybe_field_int = Some(100);
    filler.maybe_field_string = Some("Something".into());

    item.apply(filler);

    assert!(!item.field_complete);
    assert_eq!(item.field_int, 0);
    assert_eq!(item.field_string, "");
    assert_eq!(item.maybe_field_int, Some(7));
    assert_eq!(item.maybe_field_string, Some("Something".into()));
    assert_eq!(item.list.len(), 0);

    let mut filler: ItemFiller = Item::new_empty_filler();
    filler.list = vec![1, 2];
    item.apply(filler);
    assert_eq!(item.list, vec![1, 2]);

    let mut filler: ItemFiller = Item::new_empty_filler();
    filler.list = vec![3, 4];
    item.apply(filler);
    assert_eq!(item.list, vec![1, 2, 3, 4]);
}
